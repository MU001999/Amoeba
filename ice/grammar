# Grammar for Ice
# http://www.jusot.com/ice/grammar/

# Start symbols for the grammar:
#       stmt is a single interactive statemnet;
#       stmts is a module or sequence of commands read from an input file;

# Grammar for Ice
# http://www.jusot.com/ice/grammar/

# Start symbols for the grammar:
#       stmt is a single interactive statemnet;
#       stmts is a module or sequence of commands read from an input file;

%token AT;      // @
%token ATAT;    // @@

%token USING;   // using
%token IF;      // if
%token ELIF;    // elif
%token ELSE;    // else
%token WHILE;   // while
%token DO;      // do
%token FOR;     // for
%token TO;      // to
%token FOREACH; // foreach
%token AS;      // as
%token BREAK;   // break
%token CONTINUE;// continue
%token RETURN;  // return
%token MATCH;   // match

%token NEW;     // new

%token NONE;    // none
%token TRUE;    // true
%token FALSE;   // false

%token <std::string> IDENTIFIER; // [a-zA-Z_][a-zA-Z0-9_]*
%token <int64_t>     INTEGER;    // [0-9]+
%token <double>      DOUBLE;     // [0-9]+\.[0-9]*
%token <std::string> STRING;     // "[^"\n]"

%token BLS;       // <<
%token BRS;       // >>
%token AND;       // and
%token OR;        // or
%token NOT;       // not !
%token CEQ;       // =
%token CNE;       // !=
%token CLT;       // <
%token CLE;       // <=
%token CGT;       // >
%token CGE;       // >=
%token RET;       // =>
%token ADD;       // +
%token SUB;       // -
%token MUL;       // *
%token DIV;       // /
%token MOD;       // %
%token ASSIGN;    // %
%token DOT;       // .
%token COMMA;     // ,
%token LPAREN;    // (
%token RPAREN;    // )
%token LBRACKET;  // [
%token RBRACKET;  // ]
%token LBRACE;    // {
%token RBRACE;    // }

%left OR AND;
%left CEQ CNE CLT CLE CGT CGE;
%left BLS BRS;
%left ADD SUB;
%left MUL DIV MOD;

%%

%start program;

program
    : stmts
    ;

%type <Ptr<StmtList>> stmts;
stmts
    : %empty
    | stmt stmts
    ;

%type <Ptr<Stmt>> stmt;
stmt
    : decl_or_assign
    | class_decl
    | if_else
    | while_stmt
    | do_while_stmt
    | for_stmt
    | foreach_stmt
    | expr
    | RETURN expr
    | USING ident
    | CONTINUE
    | BREAK
    ;

%type <Ptr<Stmt>> decl_or_assign;
decl_or_assign
    : AT ident decl_tail ASSIGN expr
    | AT ident decl_tail LPAREN RPAREN ASSIGN expr
    | AT ident decl_tail LPAREN RPAREN block
    | AT ident decl_tail LPAREN func_decl_args RPAREN ASSIGN expr
    | AT ident decl_tail LPAREN func_decl_args RPAREN block
    | AT DOT ident decl_tail ASSIGN expr
    ;

decl_tail
    : %empty
    | DOT ident decl_tail
    | LBRACKET expr RBRACKET decl_tail
    ;

block
    : LBRACE stmts RBRACE
    ;

func_decl_args
    : ident
    | ident COMMA func_decl_args
    | ident ASSIGN expr
    | ident ASSIGN expr COMMA func_decl_args
    ;

%type <Ptr<IdentifierExpr>> ident;
ident
    : IDENTIFIER
    ;

%type <Ptr<Expr>> numeric;
numeric
    : INTEGER
    | DOUBLE
    ;

%type <Ptr<BoolExpr>> boolean;
boolean
    : TRUE
    | FALSE
    ;

%type <Ptr<StringExpr>> string;
string
    : STRING
    ;

%type <Ptr<Expr>> expr;
expr
    : expr OR expr
    | expr AND expr
    | expr CEQ expr
    | expr CNE expr
    | expr CLT expr
    | expr CLE expr
    | expr CGT expr
    | expr CGE expr
    | expr BLS expr
    | expr BRS expr
    | expr ADD expr
    | expr SUB expr
    | expr MUL expr
    | expr DIV expr
    | expr MOD expr
    | term
    | LBRACE enumerators RBRACE
    | LBRACE dictionary RBRACE
    ;

%type <Ptr<Expr>> term;
term
    : ident_or_other
    | numeric
    | boolean
    | string
    | NOT term
    | SUB term
    | LPAREN expr RPAREN
    | lambda_expr
    | new_expr
    | match_expr
    | list_expr
    | NONE
    ;

ident_or_other
    : ident another_tail
    ;

another_tail
    : %empty
    | DOT ident another_tail
    | LPAREN call_args RPAREN another_tail
    | LBRACKET expr RBRACKET another_tail
    ;

call_args
    : %empty
    | expr call_args_tail
    ;

call_args_tail
    : %empty
    | COMMA expr call_args_tail
    ;

if_else
    : IF expr block if_else_tail
    ;

if_else_tail
    : %empty
    | ELIF block if_else_tail
    | ELSE block
    ;

while_stmt
    : WHILE expr block
    ;

do_while_stmt
    : DO block WHILE expr
    ;

for_stmt
    : FOR expr TO expr AS ident block
    | FOR expr TO expr block
    ;

foreach_stmt
    : FOREACH expr AS ident block
    ;

lambda_expr
    : AT LPAREN RPAREN block decl_tail
    | AT LPAREN func_decl_args RPAREN block decl_tail
    ;

class_decl
    : ATAT ident LPAREN RPAREN block
    | ATAT ident LPAREN func_decl_args RPAREN block
    ;

new_expr
    : NEW ident LPAREN call_args RPAREN
    ;

enumerators
    : %empty
    | ident enumerators_rest
    ;

enumerators_rest
    : %empty
    | COMMA enumerators
    ;

dictionary
    : expr ASSIGN expr dictionary_rest
    ;

dictionary_rest
    : %empty
    | COMMA dictionary
    ;

match_expr
    : MATCH expr LBRACE matches RBRACE
    | MATCH expr LBRACE matches RBRACE ELSE expr
    ;

matches
    : expr call_args_tail RET expr matches_rest
    ;

matches_rest
    : %empty
    | COMMA matches
    ;

list_expr
    : LBRACKET call_args RBRACKET
    ;
